[["index.html", "Using R Packages for Reproducible Workflows Overview Acknowledgements", " Using R Packages for Reproducible Workflows Michael Dumelle September 22, 2021 Overview Welcome to the 2021 EPA R Workshop titled Using R Packages for Reproducible Workflows by me, Michael Dumelle  I am glad to have you here! Before proceeding, lets first start up R and download the devtools package. install.packages(&quot;devtools&quot;) # if required The workshops companion R package (Using R Packages for Reproducible Workflows) is available for download via devtools::install_github(repo = &quot;michaeldumelle/RPRW&quot;, ref = &quot;main&quot;) library(RPRW) Here are the sections of this workshop: Building an R Package A Research Compendia for an overview of an effective research compendia Turning An R Package into a Reproducible Research Compendia Extensions Exercise Solutions Acknowledgements I would like to thank Charlotte Wickham, Hadley Wickham, Jenny Bryan, and Yihui Xie for the immense impact their work has had on my programming journey. Much of this workshop draws from heavily their inspiration. I would also like to thank everyone who helped me hold this workshop. "],["r-package.html", "Chapter 1 Building an R Package 1.1 What is an R Package? 1.2 Creating an R Package 1.3 Debugging 1.4 Additional Resources", " Chapter 1 Building an R Package 1.1 What is an R Package? An R package is a collection of code, data, documentation, and tests with a particular structure that can be shared with others. R packages are commonly downloaded from the Comprehensive R Archive Network (CRAN). You can install them from CRAN with install.packages(\"package_name\"), load them in your workspace with library(\"package_name\"), and get help by running (help(package = \"package_name\")). One of the reasons R packages are so useful is because they are the fundamental way to share code in R. If your code is in a package, others can easily download and use it. If they are familiar with R packages, they likely will be familiar with how to use yours! But sharing R code is not the only benefit of creating R packages. Learning how to build an R package will provide several other benefits to future you! Future you will benefit from creating your own R packages because they enforce a particular structure. This structure Saves you time  you dont need to think about how to organize your files, R packages have a template! This was especially helpful for me because before learning how to create R packages, I would save my R files in all sorts of locations on my computer with all sorts of names. This made it very challenging to come back to my work later and find a particular file. Gives you standardized tools  people have created extremely useful tools that work with R packages, so take advantage of them! The R package devtools, which we downloaded earlier, contains many of these standarized tools. Requires documentation  This is especially helpful for future you. Before I started using R packages, when I would come back my old code, I was convinced someone else wrote it  I basically had to rewrite it all to understand it. R packages help prevent this. Is reproducible  R packages are built from R projects (see here and here), so file paths are relative, not absolute! read_csv(\"a_fun_csv_file.csv\") works on my machine  and yours! While R projects are not the fundamental focus on today, I highly, highly recommend you use them for every data analysis project that you are not using an R package for. Guides your data analysis  We will talk about this today See Marwick, Boettiger, and Mullen (2018) for more! 1.1.1 Exercises What are some of your favorite R packages? Of those we have talked about so far, what benefits of R packages are most appealing to you? 1.2 Creating an R Package Together, we will create the companion package for this workshop! If this is your first R package, then an extra special congratulations to you  this is a big milestone! The name of the package is 1.2.1 The Motivating Dataset Suppose we want to build an R package that summarizes length (in kilometers) and discharge (meters per second cubed) of North American rivers based on the names of the rivers. Below is our data of interest rivers &lt;- data.frame( Missouri = c(3768, 1956), Mississippi = c(3544, 18400), Yukon = c(3190, 6340), Colorado = c(2330, 40), Arkansas = c(2322, 1004), Columbia = c(2000, 7730), Red = c(1811, 852), Canadian = c(1458, 174) ) rownames(rivers) &lt;- c(&quot;length&quot;, &quot;discharge&quot;) rivers #&gt; Missouri Mississippi Yukon Colorado Arkansas Columbia Red Canadian #&gt; length 3768 3544 3190 2330 2322 2000 1811 1458 #&gt; discharge 1956 18400 6340 40 1004 7730 852 174 1.2.2 The First Step devtools::create_package(&quot;path_to_RPRW_package/RPRW&quot;)  Creating &#39;path_to_RPRW_package/RPRW/&#39;  Setting active project to &#39;path_to_RPRW_package/RPRW&#39;  Creating &#39;R/&#39;  Writing &#39;DESCRIPTION&#39; Package: RPRW Title: What the Package Does (One Line, Title Case) Version: 0.0.0.9000 Authors@R (parsed): * First Last &lt;first.last@example.com&gt; [aut, cre] (YOUR-ORCID-ID) Description: What the package does (one paragraph). License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a license Encoding: UTF-8 LazyData: true Roxygen: list(markdown = TRUE) RoxygenNote: 7.1.1  Writing &#39;NAMESPACE&#39;  Writing &#39;RPRW.Rproj&#39;  Adding &#39;^RPRW\\\\.Rproj$&#39; to &#39;.Rbuildignore&#39;  Adding &#39;.Rproj.user&#39; to &#39;.gitignore&#39;  Adding &#39;^\\\\.Rproj\\\\.user$&#39; to &#39;.Rbuildignore&#39;  Opening &#39;path_to_RPRW_package/RPRW/&#39; in new RStudio session  Setting active project to &#39;&lt;no active project&gt;&#39;  Setting active project to &#39;path_to_RPRW_package/RPRW&#39; In the Files pane of RStudio (bottom right corner), you will see that your folder has been populated with a few new files and a new folder. We will focus on some of these next. You will also notice that the Environment pane of RStudio (top right corner) now has a Build tab  this tab contains some useful tools for your R package. R (folder): Where functions in your R package are stored Description: This contains metadata for your package Namespace: Information about 1) functions from other packages your package uses and 2) what functions in your package you make available to others 1.2.3 The First Function The R folder is where functions in your R package are stored. Lets create our first function, called river_medians(), which finds the median of river length and discharge of desired rivers. Generally, the name of your file should match the name of the function, and you should use separate files for separate functions. More experienced users, it is okay to break this rule every once in a while in certain contexts. To create an R file in the R folder, run use_r(&quot;river_means&quot;) You will see some output in the console * Modify &#39;R/river_means.R&#39; * Call `use_test()` to create a matching test file and the appropriate file now in your R folder. Now lets write our function. We want this function to take the mean length and discharge of all rivers whose names have a common pattern. river_means &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers] rowMeans(new_data) } The first line of code finds the variables in the data whose names match the pattern. The second line of code subsets the data to include only the desired variables. The third line of code finds and returns the mean length and mean discharge of the desired variables. If you would like, you can leave comments in the code (using #) to remind yourself what each line of code does. This is usually good practice, as it can help others (and future you) understand the intent of your code line-by-line. 1.2.4 load_all() So we have written this function, how should we try it out? Well you could run the function or source it (source(\"R/river_means.R\")), but this puts it in our global workspace, and if you are not careful, global workspaces can get messy. The devtools function load_all() emulates the process of building, installing, and loading our R package, making all of your functions available via a single line of code. As your package becomes more complicated, it is much easier to try our your functions using load_all() than navigating the global workspace. load_all() Now lets try out our function! What if we want our summary for the rivers starting with Mi (Missiouri and Mississippi)? river_means(rivers, &quot;Mi&quot;) #&gt; length discharge #&gt; 3656 10178 Or what if we want our summary for rivers starting with Y (Yukon) or R (Red)? river_means(rivers, &quot;Y|R&quot;) #&gt; length discharge #&gt; 2500.5 3596.0 Hooray  our function works! Give yourself a congratulations :)! 1.2.4.1 Exercises How many functions does river_means() call within the body of the function? What package are these functions in? 1.2.5 Creating Package Data So far we have used the rivers data from our global workspace. But what if we want this to be data that is included as part of the R packages so that others (or future you) have easy access to it? This is the place for use_data() use_data(rivers)  Creating &#39;data/&#39;  Saving &#39;rivers&#39; to &#39;data/rivers.rda&#39; You will see that at the root of your R package, there is a folder called data, and in that folder is a file called rivers.rda, which contains the rivers data. For illustration, lets remove rivers from our global workspace and then load it like we would data from any other package rm(rivers) # remove the rivers data from our global workspace load_all() # emulate package building process data(&quot;rivers&quot;) # load the rivers data rivers 1.2.6 roxygen Comments Now that you have written your function, it is time to thoroughly document your function so that others (or future you) can understand how to use it. The documentation for R functions uses special types of comments called roxygen comments. The comments use #' and have special tags associated with them. To insert a template of roxygen comments into river_means(), put your cursor somewhere in the river_means() function and either In the upper-left toolbar, go to Code -&gt; Insert Roxygen Skeleton Press Ctrl/Cmd + Alt + Shift + R You will see river_means() now looks like #&#39; Title #&#39; #&#39; @param data #&#39; @param pattern #&#39; #&#39; @return #&#39; @export #&#39; #&#39; @examples river_means &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers] rowMeans(new_data) } The @ indicates a particular tag that controls how functions are documented. @param: for documenting arguments to a function @return: for documenting the function output @export: for making this function available to others downloading your package @examples: to give examples for how to use the package Lets fill these in. #&#39; Means of river lengths and discharges #&#39; #&#39; @param data A data frame with two rows. The first row indicates river length and #&#39; second row indicates river discharge. The columns of data indicate river names. #&#39; @param pattern A pattern by which to include only particular rivers #&#39; #&#39; @return The mean river length and mean river discharge for the desired rivers #&#39; @export #&#39; #&#39; @examples #&#39; data(&quot;rivers&quot;) #&#39; river_means(rivers, pattern = &quot;Mi&quot;) river_means &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers] rowMeans(new_data) } To view this documentation as you would any other packages function documentation, first run document() i Updating RPRW documentation i Loading RPRW Writing NAMESPACE Writing river_means.Rd You will notice that there is a new folder at the root of the package, called man, which contains a file called river_means.Rd. The contents of the file here are not too important, as this file is automatically created using document(). The important point is that after running document(), you can view the documentation of your function! ?river_means There are several other tags available to customize your documentation  for more information about these tags and documenting data (which is different than documentation function; the rivers data is documented in the RPRW package hosted on GitHub), see here. Though we skip it here, the RPRW package source does document the rivers data and can be viewed using ?rivers after loading RPRW. 1.2.7 The Second Function In river_means(), we used a few functions: &lt;-, grep(), names(), [, and rowMeans(). These functions are all from the base package, which is a special package in the way that it operates with R packages. If you use functions from the base package in your package, you dont have to give R any warning. If you use a function from another package, however, you do need to let R know where that function is coming from. Next we explore this. Suppose we want to create a function in our package that computes the mean instead of a mean. First we run use_r(&quot;river_medians&quot;) Then we write the function. Note that there is no rowMedians() function, so we use apply() to summarize across rows (see ?apply for more detail). river_medians &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers] apply(new_data, 1, median) } But wait! Youll notice that the function median() is in the stats package, not the base package (run ?median to check). So we need to let R know that we will be using a function from a package that is not the base package. To accomplish this, there are two steps to take. First, you need to tell R that you are using another package use_package(&quot;stats&quot;)  Adding &#39;stats&#39; to Imports field in DESCRIPTION * Refer to functions with `stats::fun()` You will notice that the package stats was added to the Imports field in the DESCRIPTION file  we will get to DESCRIPTION later, but for now just remember that it contains metadata about your package. You only need to run use_package(\"stats\") once per package. That is, if you are using a different function from stats, you dont need to run use_package(\"stats\") again. Second, you need to tell the river_median() function to use the median() function from the stats package. The best practice is to preface any function from outside the base package with packagename::. This adjustment to river_median() yields river_medians &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers] apply(new_data, 1, stats::median) } Though this is the best practice, it does add some extra typing and can be cumbersome if you are using outside functions often. The packagename:: prefix can be avoided if you import median() to river_median() using the roxygen tag @importFrom #&#39; Medians of river lengths and discharges #&#39; #&#39; @param data A data frame with two rows. The first row indicates river length and #&#39; second row indicates river discharge. The columns of data indicate river names. #&#39; @param pattern A pattern by which to include only particular rivers #&#39; #&#39; @return The median river length and mean river discharge for the desired rivers #&#39; @importFrom stats median #&#39; @export #&#39; #&#39; @examples #&#39; data(&quot;rivers&quot;) #&#39; river_medians(rivers, pattern = &quot;Mi&quot;) river_medians &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers] apply(new_data, 1, median) } If you are using several functions from stats, it may be easier to use the @import tag, which imports all functions from a package at once. #&#39; Medians of river lengths and discharges #&#39; #&#39; @param data A data frame with two rows. The first row indicates river length and #&#39; second row indicates river discharge. The columns of data indicate river names. #&#39; @param pattern A pattern by which to include only particular rivers #&#39; #&#39; @return The median river length and mean river discharge for the desired rivers #&#39; @import stats #&#39; @export #&#39; #&#39; @examples #&#39; data(&quot;rivers&quot;) #&#39; river_medians(rivers, pattern = &quot;Mi&quot;) river_medians &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers] apply(new_data, 1, median) } Be careful when using @importFrom or @import to ensure that two functions from different packages dont have the same name  this is when using packagename:: to prefix the function is crucial. 1.2.7.1 Exercises Play around with using these functions for some new patterns  do you notice anything strange? These exercises are more challenging, so if they dont make sense now, that is okay! Make sure to re-review the solutions after the workshop. Write a new function, river_stat(), that takes a data frame, pattern, and a general function by which to summarize river length and discharge. This general function should not be an actual function but rather a placeholder so that a user may insert their own function as an argument. Rewrite river_stat() so that it also takes additional arguments to the summarizing function (hint: use ... as an argument) 1.2.8 DESCRIPTION The DESCRIPTION file is automatically added while creating an R package and contains the R packages metadata. Package: RPRW Title: R Packages for Reproducible Workflows Version: 0.0.0.9000 Authors@R: person(given = &quot;Michael&quot;, family = &quot;Dumelle&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;), email = &quot;first.last@example.com&quot;) Description: A companion R package for &quot;Using R Packages for Reproducible Workflows&quot; at the 2021 EPA R Workshop. License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a license Encoding: UTF-8 LazyData: true Roxygen: list(markdown = TRUE) RoxygenNote: 7.1.1 Depends: R (&gt;= 2.10) Imports: stats The DESCRIPTION file is where you track version numbers, authorship, and additional R packages that your R package uses. Two fields in DESCRIPTION do most of the communication regarding how your R package uses additional R packages: Imports: Packages here must be installed in order for your package to work. As a result, any package listed in Imports will be installed alongside your package. Packages in Imports help build the foundation of your package. Suggests: Packages here enhance your package but are not required for your package to work. You might use suggested packages for enhanced plotting, additional data sets, or more. Packages in Suggests can add finishing touches to your package, but they are not part of your packages foundation. Other fields used to communicate how your R package uses additional R packages are Depends, LinkingTo, and Enhances. The difference between Depends and Imports is subtle  the general advice is to use Imports instead of Depends. 1.2.9 NAMESPACE While the DESCRIPTION file communicates what packages your package uses, the NAMESPACE file communicates how your package uses these packages. More specifically, the NAMESPACE file controls which functions your package exports (makes available to others) and what functions from what packages must be available for your exported functions to work. This file is automatically generated by devtools and should not be edited by hand. In river_median(), if you called median using stats::median, your NAMESPACE file will look like # Generated by roxygen2: do not edit by hand export(river_means) export(river_medians) If you used the @importFrom stats median approach, your NAMESPACE will look like # Generated by roxygen2: do not edit by hand export(river_means) export(river_medians) importFrom(stats,median) If you used the @import stats approach, your NAMESPACE will look like # Generated by roxygen2: do not edit by hand export(river_means) export(river_medians) import(stats) 1.2.10 testthat Testing your code to make sure that it performs as intended is an important step in the package building process. Though upfront, it may seem like extra work, implementing a rigorous testing procedure for your package will provide several benefits: fewer bugs, better code structure, easier restarts, and robust code. In R, testing is incorporated into your package through the testthat package. To begin using testthat, run use_testthat()  Adding &#39;testthat&#39; to Suggests field in DESCRIPTION  Setting Config/testthat/edition field in DESCRIPTION to &#39;3&#39;  Creating &#39;tests/testthat/&#39;  Writing &#39;tests/testthat.R&#39; The root of your package directory shoudl look like The tests folder should look like Tests are generally written on a function-by-function basis. All tests for a function are contained in an R script titled test-function_name. For example, to start testing river_means(), run use_test(&quot;river_means&quot;)  Writing &#39;tests/testthat/test-river_means.R&#39; * Modify &#39;tests/testthat/test-river_means.R&#39; Your testthat folder should look like Tests can be fairly detailed and cover many components of a function (such as input types, output types, function output, etc.). Here we write a simple test that calculates whether our function, river_means(), yields output that we would expect if we calculated the means by hand for an example scenario where our pattern includes Missouri and Mississippi. test_that(&quot;the mean length is calculated correctly in a test case&quot;, { # calculate values required for the test for length ## calculate the means from the function river_means_val &lt;- river_means(rivers, &quot;Missouri|Mississippi&quot;) river_means_length &lt;- river_means_val[[1]] ## calculate the means &quot;by hand&quot; raw_vec_length &lt;- unlist(rivers[&quot;length&quot;, c(&quot;Missouri&quot;, &quot;Mississippi&quot;)]) raw_means_length &lt;- mean(raw_vec_length) # perform the actual test for length ## check that the function and &quot;by hand&quot; output matches expect_equal(river_means_length, raw_means_length) }) #&gt; Error in test_that(&quot;the mean length is calculated correctly in a test case&quot;, : could not find function &quot;test_that&quot; The tests in testthat are prefixed with expect_. If you have many tests, the test() function runs all of them in the testthat folder: test() i Loading RPRW i Testing RPRW  | OK F W S | Context  | 1 | river_means == Results ========================================================================= [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ] We can write a similar test for discharge and then repeat the process for river_meadians(). Then test() returns test() i Loading RPRW i Testing RPRW  | OK F W S | Context  | 2 | river_means  | 2 | river_medians == Results ========================================================================= [ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ] All tests pass  hooray! I want to again emphasize how important testing is. I know that it seems like an extra chore, but in my experience, writing careful tests has always paid offwith interest. 1.2.10.1 Exercises Write similar tests for river_means() (discharge), river_medians() (length), and river_medians() (length) 1.2.11 License At some point, your package needs a license. The license places restrictions on how your package can be shared with others. Licensing can be complicated quickly, so I refer you here for more information. For illustration purposes, we will use a GPL-3 license for this package. use_gpl_license()  Setting active project to &#39;path_to_RPRW_package/RPRW&#39;  Setting License field in DESCRIPTION to &#39;GPL (&gt;= 3)&#39;  Writing &#39;LICENSE.md&#39;  Adding &#39;^LICENSE\\\\.md$&#39; to &#39;.Rbuildignore&#39; The licensing update will be reflected in the DESCRIPTION file. 1.2.12 Vignettes Vignettes act as high-level user guides for your package. A vignette acts as the glue that binds together all the documentation from the individual functions to solve a particular problem. Typically, they guide the user through a typical workflow one would experience while using your package. The ggplot2 package is a popular package for visualizing data. After installing ggplot2 install.packages(&quot;ggplot2&quot;) you can view its available vignettes by running vignette(package = &quot;ggplot2&quot;) A file will pop up alongside your R scripts with the contents Then to view a specific vignette, run vignette(topic, package). For example, to view the vignette regarding aesthetic specifications, run vignette(&quot;ggplot2-specs&quot;, &quot;ggplot2&quot;) You will then see the vignette in the bottom-right hand pane of RStudio. Vignettes are also available on a packages CRAN page  for the ggplot2 aesthetic specifications vignette, see here. To include vignettes in your R package, first run use_vignette(&quot;river-statistics&quot;, &quot;River Statistics&quot;)  Adding &#39;knitr&#39; to Suggests field in DESCRIPTION  Setting VignetteBuilder field in DESCRIPTION to &#39;knitr&#39;  Adding &#39;inst/doc&#39; to &#39;.gitignore&#39;  Creating &#39;vignettes/&#39;  Adding &#39;*.html&#39;, &#39;*.R&#39; to &#39;vignettes/.gitignore&#39;  Adding &#39;rmarkdown&#39; to Suggests field in DESCRIPTION  Writing &#39;vignettes/river-statistics.Rmd&#39; * Modify &#39;vignettes/river-statistics.Rmd&#39; A few things happen after running use_vignette(): your DESCRIPTION file is edited, a vignettes folder is inserted into the root of your directory, and a .Rmd file is added to the vignettes folder. The .Rmd file extension indicates that the vignette is an RMarkdown document. RMarkdown documents provide a convenient way to create dynamic documents. Dynamic documents combine code and text and form the foundation for reproducible report writing in R. More on RMarkdown is available here, here and here. I highly recommend you get some experience with it, as its tools are quite powerful. While we wont create a vignette for our package during the workshop, I have added a vignette to the companion R package. After installation, it can be viewed by running vignette(river-statistics, &quot;RPRW&quot;) 1.2.13 check() So now we have built our R package and are ready to share it with the world! But we should probably check to make sure we did not make any small mistakes? This is what check() does  it runs through a series of checks on your package to make sure it can be properly installed and shared. check() takes a few minutes to run, but it will return errors, warnings, and notes associated with your package. Though the warnings and notes are important, it is most crucial to address the errors immediately. Hopefully your output after running check() looks like -- R CMD check results ---------- RPRW 0.0.0.9000 ---- Duration: 34.4s 0 errors  | 0 warnings  | 0 notes  1.2.14 install() After check() returns zero errors (and hopefully zero warnings and notes), you can install your package by running install() After installation, you can use library() to load your package (like you do any other R package). 1.2.15 Congratulations Congratulations on building an R package! 1.3 Debugging Even the best of programmers write code that may fail in unintended ways. This is referred to as a bug, and the process of fixing the bug is known as debugging. Dont expect to always write perfect code  do expect to have the tools necessary to track down bugs and remedy them. Though we went through a rigorous documentation and testing procedure when creating river_means() and river_medians(), there are still bugs present in these functions. 1.3.1 A Mysterious Error Message We have used river_means() and river_medians() to successfully find means and medians for all sorts of river combinations. But running river_means(rivers, &quot;R&quot;) #&gt; Error in rowMeans(new_data): &#39;x&#39; must be an array of at least two dimensions yields a mystifying error. Something is wrong  and we need to figure out what. A good first step is to copy and paste the error into a Google search engine and see if anyone has solved the problem yet. If you are lucky, this will help you find the bug. If not, you need to use another approach. Fortunately, R has tools to help isolate bugs. 1.3.2 traceback() The traceback() function is run after code generating an error and it identifies where the error occurred. traceback() #&gt; No traceback available Locating the source of bugs goes a long way towards removing them. Here, we see that the function failed at the rowMeans() step of river_means(). While useful, we still dont exactly know why the error is occurring. 1.3.3 browser() Before I learned about browser(), I would try to debug by storing my arguments locally (so that they were in the global environment) and then sequentially running each line of the function one-at-a-time. Perhaps some of you have done this too. Unfortunately, for many reasons (which we dont discuss in detail today), its an inferior method of debugging compared to browser(). The browser() method involves inserting browser() into the body of your function. Running your function with browser() inside of it then lets you interactively step into the function at browser(). No more storing arguments and running code line-by-line! Lets try this out with river_means() river_means &lt;- function(data, pattern) { browser() desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers] rowMeans(new_data) } Now when running river_means(), you will step into the function. For example, river_means(rivers, &quot;R&quot;) will open a new file that looks like In your new interactive context, you will see a few buttons in the R console (lower left-hand window) These are five buttons to type into the console and evaluate (Enter/Return) that let you navigate the interactive context. In order (left to right), they are Next (n) executes the next line of the code Step (s) steps into the function called by the current line of code Finish (f) finishes execution of the current function Continue (c) leaves the interactive context and continues execution of the function Stop (Q) leaves the interactive context and terminates execution of the function In the interactive context of river_means(), we see data and pattern are defined: print(data) #&gt; Missouri Mississippi Yukon Colorado Arkansas Columbia Red Canadian #&gt; length 3768 3544 3190 2330 2322 2000 1811 1458 #&gt; discharge 1956 18400 6340 40 1004 7730 852 174 print(pattern) #&gt; [1] &quot;R&quot; Pressing n executes browser(). Pressing n again executes desired_rivers &lt;- grep(pattern, names(data)) Inspecting desired_rivers, we see print(desired_rivers) #&gt; [1] 7 This seems correct, so the error does not appear to be here. Lets press n to evaluate the next line new_data &lt;- data[, desired_rivers] Inspecting new_data, we see new_data #&gt; [1] 1811 852 Well this seems weird  it does not look like a data frame. Lets inspect the structure str(new_data) #&gt; num [1:2] 1811 852 It is not a data frame, but rather a numeric vector. Because rowMeans() requires an array of two or more dimensions (e.g. matrix or data frame), the next line of code fails. Pressing n again returns the error and removes you from the interactive context rowMeans(new_data) #&gt; Error in rowMeans(new_data): &#39;x&#39; must be an array of at least two dimensions A similar error occurs within river_medians() when running apply() So what is happening here? We know the code works when the pattern yields at least two matches in rivers, and we know the code behaves oddly when the pattern only has one match. Looking at the documentation of [ we see a drop argument, which coerces to the lowest possible dimension when equal to TRUE. When subsetting data frames, drop is TRUE by default. So when subsetting a data frame using a single column, the data frame structure is only preserved when drop = FALSE. Accommodating this change in river_means() and river_medians() yields functions whose bodies looks like river_means &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers, drop = FALSE] rowMeans(new_data) } river_medians &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers, drop = FALSE] apply(new_data, 1, median) } Running these functions with pattern = \"R\" behaves as intended river_means(rivers, &quot;R&quot;) #&gt; length discharge #&gt; 1811 852 river_medians(rivers, &quot;R&quot;) #&gt; length discharge #&gt; 1811 852 For more information about debugging in R, watch or read. 1.3.4 Another Error  No Mysterious Message We received and fixed an error message that occurred when the pattern only matched one river. But what happens when it matches zero rivers? river_means(rivers, &quot;ZZZ&quot;) river_medians(rivers, &quot;ZZZ&quot;) These types of bugs are especially pernicious because there is no error message associated with them. Whenever the output is unexpected, use browser() to diagnose the problem. In this context, desired_rivers is a length-zero vector, which causes problems in the remaining parts of the function. To guard against these types of bugs, program defensively and force the function to return an error message early. river_means &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) if (length(desired_rivers) == 0) { stop(&quot;This is an error message that stops the function&quot;) } new_data &lt;- data[, desired_rivers, drop = FALSE] rowMeans(new_data) } river_means(rivers, &quot;ZZZ&quot;) #&gt; Error in river_means(rivers, &quot;ZZZ&quot;): This is an error message that stops the function 1.3.4.1 Exercises Rewrite river_medians() so that it stops when no patterns are matched and returns an informative error message. 1.4 Additional Resources R Packages by Hadley Wickham and Jenny Bryan Writing an R package from scratch by Hilary Parker Writing R Extensions by CRAN (this resource is very technical) References "],["a-research-compendia.html", "Chapter 2 A Research Compendia", " Chapter 2 A Research Compendia Placeholder "],["your-compendia.html", "Chapter 3 Turning An R Package into a Reproducible Research Compendia", " Chapter 3 Turning An R Package into a Reproducible Research Compendia "],["extensions.html", "Chapter 4 Extensions 4.1 RMarkdown 4.2 GitHub", " Chapter 4 Extensions 4.1 RMarkdown 4.2 GitHub "],["exercise-solutions.html", "Chapter 5 Exercise Solutions", " Chapter 5 Exercise Solutions Q 1. What are some of your favorite R packages? A 1. This is for you to answer! Though a few of my favorites include devtools, styler, rticles, rlang, and purrr. Q 1. Of those ew have talked about so far, what benefits of R packages are most appealing to you? A 1. This is also for you to answer. My answer is all of them!, though if I had to pick one, it is saving time by enforcing a structure  future me appreciates when past me does this. Q 1. How many functions does river_means() call within the body of the function? What package are these functions in? A 1. There are five functions: &lt;-, grep(), names(), [, and rowMeans(). They are all in the base package, which can been seen in each functions documentation ?`&lt;-` ?grep ?names ?`[` ?rowMeans Q 1. Play around with using these functions for some new patterns  do you notice anything strange? A 1. If zero matches or one match occur for a pattern, there is some unexpected behavior. If there are zero matches, you get NaN for an answer (which stands for not a number). river_means(rivers, &quot;ZZZ&quot;) If there is one match, you get a mysterious error  more on this later. river_means(rivers, &quot;Red&quot;) Q 1. Write a new function, river_stat(), that takes a data frame, pattern, and a general function by which to summarize river length and discharge. This general function should not be an actual function but rather a placeholder so that a user may insert their own function as an argument. A 1. #&#39; Summary statistics of river lengths and discharges #&#39; #&#39; @param data A data frame with two rows. The first row indicates river length and #&#39; second row indicates river discharge. The columns of data indicate river names. #&#39; @param pattern A pattern by which to include only particular rivers #&#39; @param FUN A function to summarize the rivers #&#39; #&#39; @return The summarized river length and mean river discharge for the desired rivers #&#39; @export #&#39; #&#39; @examples #&#39; data(&quot;rivers&quot;) #&#39; river_stat(rivers, &quot;Mi&quot;, min) river_stat &lt;- function(data, pattern, FUN) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers] apply(new_data, 1, FUN) } river_stat(rivers, &quot;Mi&quot;, min) #&gt; length discharge #&gt; 3544 1956 river_stat(rivers, &quot;Mi&quot;, max) #&gt; length discharge #&gt; 3768 18400 river_stat(rivers, &quot;Mi&quot;, mean) #&gt; length discharge #&gt; 3656 10178 river_stat(rivers, &quot;Mi&quot;, stats::median) #&gt; length discharge #&gt; 3656 10178 Q 1. Rewrite river_stat() so that it also takes additional arguments to the summarizing function (hint: use ... as an argument) A 1. #&#39; Summary statistics of river lengths and discharges #&#39; #&#39; @param data A data frame with two rows. The first row indicates river length and #&#39; second row indicates river discharge. The columns of data indicate river names. #&#39; @param pattern A pattern by which to include only particular rivers #&#39; @param FUN A function to summarize the rivers #&#39; @param ... Additional arguments to pass to \\code{FUN} #&#39; #&#39; @return The summarized river length and mean river discharge for the desired rivers #&#39; @export #&#39; #&#39; @examples #&#39; data(&quot;rivers&quot;) #&#39; river_stat(rivers, &quot;Mi|C&quot;, mean, trim = 0.5) river_stat &lt;- function(data, pattern, FUN, ...) { desired_rivers &lt;- grep(pattern, names(data)) new_data &lt;- data[, desired_rivers] apply(new_data, 1, FUN, ...) } river_stat(rivers, &quot;Mi|C&quot;, mean, trim = 0) #&gt; length discharge #&gt; 2620 5660 river_stat(rivers, &quot;Mi|C&quot;, mean, trim = 0.5) #&gt; length discharge #&gt; 2330 1956 Q 1. Write similar tests for river_means() (discharge), river_medians() (length), and river_medians() (length) A 1. test_that(&quot;the mean discharge is calculated correctly in a test case&quot;, { # calculate values required for the test for discharge ## calculate the means from the function river_means_val &lt;- river_means(rivers, &quot;Missouri|Mississippi&quot;) river_means_discharge &lt;- river_means_val[[2]] ## calculate the means &quot;by hand&quot; raw_vec_discharge &lt;- unlist(rivers[&quot;discharge&quot;, c(&quot;Missouri&quot;, &quot;Mississippi&quot;)]) raw_means_discharge &lt;- mean(raw_vec_discharge) # perform the actual test for discharge ## check that the function and &quot;by hand&quot; output matches expect_equal(river_means_discharge, raw_means_discharge) }) #&gt; Error in test_that(&quot;the mean discharge is calculated correctly in a test case&quot;, : could not find function &quot;test_that&quot; test_that(&quot;the median length is calculated correctly in a test case&quot;, { # calculate values required for the test for length ## calculate the medians from the function river_medians_val &lt;- river_medians(rivers, &quot;Missouri|Mississippi&quot;) river_medians_length &lt;- river_medians_val[[1]] ## calculate the medians &quot;by hand&quot; raw_vec_length &lt;- unlist(rivers[&quot;length&quot;, c(&quot;Missouri&quot;, &quot;Mississippi&quot;)]) raw_medians_length &lt;- median(raw_vec_length) # perform the actual test for length ## check that the function and &quot;by hand&quot; output matches expect_equal(river_medians_length, raw_medians_length) }) #&gt; Error in test_that(&quot;the median length is calculated correctly in a test case&quot;, : could not find function &quot;test_that&quot; test_that(&quot;the mean discharge is calculated correctly in a test case&quot;, { # calculate values required for the test for discharge ## calculate the medians from the function river_medians_val &lt;- river_medians(rivers, &quot;Missouri|Mississippi&quot;) river_medians_discharge &lt;- river_medians_val[[2]] ## calculate the medians &quot;by hand&quot; raw_vec_discharge &lt;- unlist(rivers[&quot;discharge&quot;, c(&quot;Missouri&quot;, &quot;Mississippi&quot;)]) raw_medians_discharge &lt;- median(raw_vec_discharge) # perform the actual test for discharge ## check that the function and &quot;by hand&quot; output matches expect_equal(river_medians_discharge, raw_medians_discharge) }) #&gt; Error in test_that(&quot;the mean discharge is calculated correctly in a test case&quot;, : could not find function &quot;test_that&quot; Q 1. Rewrite river_medians() so that it stops when no patterns are matched and returns an informative error message. A 1. river_medians &lt;- function(data, pattern) { desired_rivers &lt;- grep(pattern, names(data)) if (length(desired_rivers) == 0) { stop(&quot;The pattern provided does not match any rivers in the data provided&quot;) } new_data &lt;- data[, desired_rivers, drop = FALSE] rowMeans(new_data) } river_medians(rivers, &quot;ZZZ&quot;) #&gt; Error in river_medians(rivers, &quot;ZZZ&quot;): The pattern provided does not match any rivers in the data provided The error messages in the RPRW package are more informative but more difficult to code. "],["references.html", "References", " References "]]
