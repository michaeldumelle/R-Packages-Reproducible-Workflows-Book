# Exercise Solutions {#exercise-solutions}

```{r, eval = TRUE, echo = FALSE}
river_means <- function(data, pattern) {
  desired_rivers <- grep(pattern, names(data))
  new_data <- data[, desired_rivers]
  rowMeans(new_data)
}
```

## Building an R Package {-}

**[Exercise 1.1.1.1](#ex-set1)** What are some of your favorite R packages?

**Answer 1.1.1.1** This is for you to answer! I have many favorites, but a few are devtools, styler, rticles, rlang, and purrr.

**[Exercise 1.1.1.2](#ex-set1)** Of those we have talked about so far, what benefits of R packages are most appealing to you?

**Answer 1.1.1.2** This is for you to answer! The most appealing benefit to me is the structure that helps keep me organized.

**[Exercise 1.2.4.1.1](#ex-set2)** How many functions does `river_means()` call within the body of the function? What package are these functions in?

**Answer 1.2.4.1.1** 1. There are five functions: `<-`, `grep()`, `names()`, `[`, and `rowMeans()`. They are all in the "base" package -- this fact be can seen in each function's documentation
```{r}
?`<-`
?grep
?names
?`[`
?rowMeans
```

**[Exercise 1.2.4.1.2](#ex-set2)** Try using `river_means()` with a few different patterns. Do you notice anything strange?

**Answer 1.2.4.1.1** 

Strange behavior occurs when the pattern matches only one river or zero rivers. If the pattern matches only one river, there is an error:
```{r, eval = TRUE}
river_means(river, "R")
```

If the pattern matches zero rivers, the mean is `NaN` (which stands for not a number)
```{r, eval = TRUE}
river_means(river, "ZZZ")
```

These are both unintended and are discussed more in [Debugging](#debugging).

**[Exercise 1.2.7.1.1](#ex-set3)** Write a new function, `river_stats()`, that takes a data frame, pattern, and a general function by which to summarize river length and discharge. This general function should not be an actual function but rather a placeholder for a function a user inserts themselves.

**Answer 1.2.7.1.1**

```{r, eval = TRUE}
#' Summary statistics of river lengths and discharges
#'
#' @param data A data frame with two rows. The first row indicates river length and
#'   second row indicates river discharge. The columns of data indicate river names.
#' @param pattern A pattern by which to include only particular rivers
#' @param FUN A function to summarize the rivers
#'
#' @return The summarized river length and mean river discharge for the desired rivers
#' @export
#'
#' @examples
#' data("river")
#' river_stat(river, "Mi", min)
river_stats <- function(data, pattern, FUN) {
  desired_rivers <- grep(pattern, names(data))
  new_data <- data[, desired_rivers]
  apply(new_data, 1, FUN)
}
river_stats(river, "Mi", min)
river_stats(river, "Mi", max)
river_stats(river, "Mi", mean)
river_stats(river, "Mi", stats::median)
```

**[Exercise 1.2.7.1.2](#ex-set3)** Rewrite `river_stats()` from the previous exercise so that `river_stats()` also takes additional arguments to the summarizing function (hint: use `...` as an argument)

**Answer 1.2.7.1.2**
 
```{r, eval = TRUE}
#' Summary statistics of river lengths and discharges
#'
#' @param data A data frame with two rows. The first row indicates river length and
#'   second row indicates river discharge. The columns of data indicate river names.
#' @param pattern A pattern by which to include only particular rivers
#' @param FUN A function to summarize the rivers
#' @param ... Additional arguments to pass to \code{FUN}
#'
#' @return The summarized river length and mean river discharge for the desired rivers
#' @export
#'
#' @examples
#' data("river")
#' river_stat(river, "Mi|C", mean, trim = 0.5)
river_stats <- function(data, pattern, FUN, ...) {
  desired_rivers <- grep(pattern, names(data))
  new_data <- data[, desired_rivers]
  apply(new_data, 1, FUN, ...)
}
river_stats(river, "Mi|C", mean, trim = 0)
river_stats(river, "Mi|C", mean, trim = 0.5)
```

**[Exercise 1.2.10.1](#ex-set4)** Write similar tests for `river_means()` (discharge), `river_medians()` (length), and `river_medians()` (discharge).

**Answer 1.2.10.1** 

```{r, eval = TRUE}
testthat::test_that("the mean discharge is calculated correctly in a test case", {
  
  # calculate values required for the test for discharge

  ## calculate the means from the function
  river_means_val <- river_means(river, "Missouri|Mississippi")
  river_means_discharge <- river_means_val[[2]]

  ## calculate the means "by hand"
  raw_vec_discharge <- unlist(river["discharge", c("Missouri", "Mississippi")])
  raw_means_discharge <- mean(raw_vec_discharge)
  
  # perform the actual test for discharge

  ## check that the function and "by hand" output matches
  expect_equal(river_means_discharge, raw_means_discharge)
})
```

```{r, eval = TRUE}
testthat::test_that("the median length is calculated correctly in a test case", {
  
  # calculate values required for the test for length

  ## calculate the medians from the function
  river_medians_val <- river_medians(river, "Missouri|Mississippi")
  river_medians_length <- river_medians_val[[1]]

  ## calculate the medians "by hand"
  raw_vec_length <- unlist(river["length", c("Missouri", "Mississippi")])
  raw_medians_length <- median(raw_vec_length)
  
  # perform the actual test for length

  ## check that the function and "by hand" output matches
  expect_equal(river_medians_length, raw_medians_length)
})
```

```{r, eval = TRUE}
testthat::test_that("the mean discharge is calculated correctly in a test case", {
  
  # calculate values required for the test for discharge

  ## calculate the medians from the function
  river_medians_val <- river_medians(river, "Missouri|Mississippi")
  river_medians_discharge <- river_medians_val[[2]]

  ## calculate the medians "by hand"
  raw_vec_discharge <- unlist(river["discharge", c("Missouri", "Mississippi")])
  raw_medians_discharge <- median(raw_vec_discharge)
  
  # perform the actual test for discharge

  ## check that the function and "by hand" output matches
  expect_equal(river_medians_discharge, raw_medians_discharge)
})
```

**[Exercise 1.2.14.1.1](#ex-set5)**
Find the argument to `devtools::install()` that identifies whether vignettes are built alongside installation. What is the default value of this argument?

**Answer 1.2.14.1.1** Running 
```{r}
?devtools_install
```
we see that `build_vignettes` controls whether vignettes are build alongside installation. The default arguent for `build_vignettes` is `FALSE`.



**[Exercise 1.3.4.1.1](#ex-set6)**
Rewrite `river_medians()` so that it stops and returns an informative error message when the pattern matches zero rivers.

**Answer 1.3.4.1.1**
```{r, eval = TRUE}
river_medians <- function(data, pattern) {
  desired_rivers <- grep(pattern, names(data))
  if (length(desired_rivers) == 0) {
    stop("The pattern provided does not match any rivers in the data provided.")
  }
  new_data <- data[, desired_rivers, drop = FALSE]
  rowMeans(new_data)
}
river_medians(rivers, "ZZZ")
```

The error messages in the `RPRW` package are more informative but more difficult to code.

## Making an R Package a Research Compendium {-}

*Q* 2. Can you identify any benefits to a research compendium?

*A* 2. Individual answer

*Q* 2. Can you identify any benefits to a research compendium that are not already on this list?

*A* 2. Individual answer
